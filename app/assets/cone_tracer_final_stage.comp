#version 430 core

layout (local_size_x = 8, local_size_y = 8) in;
layout (rgba32f, binding = 0) uniform writeonly image2D outputTexture;
layout (r32f, binding = 1) uniform readonly image2D distancesTexture;

uniform samplerCube u_skyboxTexture;

uniform mat4 u_inv_view_proj_mat;
uniform vec3 u_position;
uniform uint u_width;
uniform uint u_height;

uniform float u_time_in_seconds;
uniform float u_epsilon;
uniform float u_max_distance;
uniform uint u_max_iteration_count;


#include "assets/sdf.include"


struct Ray {
    vec3 position;
    vec3 direction;
};



void naive_sphere_tracing(Ray ray, float t0) {
    float t = t0;
    float d;

    uint steps = 0;
    do {
        vec3 current_position = ray.position + t * ray.direction;
        d = abs(sdf(current_position).d);
        t += d;
        steps++;
    } while (d > u_epsilon * t && t < u_max_distance && steps < u_max_iteration_count);

    if (d <= u_epsilon * t) {
        vec3 current_position = ray.position + t * ray.direction;
        vec3 normal = Normal(current_position);
        float dif = clamp(dot(normal, vec3(0.57703)), 0.0, 1.0);
        float amb = 0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0));
        vec3 color = vec3(0.2, 0.3, 0.4) * amb + vec3(0.8, 0.7, 0.5) * dif;
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
    } else if (t >= u_max_distance){
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), texture(u_skyboxTexture, ray.direction));
    } else {
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 0.0));
    }
}

void Render(Ray ray, float t) {
    if (t >= u_max_distance) {
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), texture(u_skyboxTexture, ray.direction));
    } else if (t >= 0) {
        naive_sphere_tracing(ray, t);
    } else {
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 0.0));
    }
}

void main() {
    if (gl_GlobalInvocationID.x >= u_width || gl_GlobalInvocationID.y >= u_height) {
        return;
    }

    vec2 normalized_pixel_coord = vec2(gl_GlobalInvocationID.xy) / vec2(u_width, u_height);
    vec2 ndc_coord = normalized_pixel_coord * 2.0 - 1.0 + (1.0 / float(u_height));
    vec4 projected_position = u_inv_view_proj_mat * vec4(ndc_coord, -1.0, 1.0);
    projected_position /= projected_position.w;
    vec3 ray_dir = normalize(projected_position.xyz - u_position);

    Render(Ray(u_position, ray_dir), imageLoad(distancesTexture, ivec2(gl_GlobalInvocationID.xy / 2)).r);
}