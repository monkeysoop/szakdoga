#ifndef RENDERER_INCLUDE
#define RENDERER_INCLUDE



#include "assets/tracers.include"
#include "assets/tracing_result.include"
#include "assets/ray.include"



vec3 Render(Ray ray, float initial_t, float initial_iteration) {
    if (initial_t >= u_max_distance || initial_iteration >= u_max_iteration_count) {

#if RENDER_MODE == NORMAL
        if (initial_iteration >= u_max_iteration_count) {
            return vec3(1.0, 0.0, 0.0);
        } else {
            return texture(u_skyboxTexture, ray.direction).rgb;
        }
#elif RENDER_MODE == ITERATION_COUNT
        return vec3(initial_iteration / u_max_iteration_count);
#elif RENDER_MODE == DEPTH
        return vec3(initial_t / u_max_distance);
#endif
    
    } else {

        TracingResult tracing_result = SphereTracing(ray, initial_t, initial_iteration);

#if RENDER_MODE == NORMAL
        if (tracing_result.result == TRACING_RESULT_HIT) {
            vec3 position = ray.position + tracing_result.t * ray.direction;
            vec3 normal = Normal(position);
            float dif = clamp(dot(normal, vec3(0.57703)), 0.0, 1.0);
            float amb = 0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0));
            vec3 color = vec3(0.2, 0.3, 0.4) * amb + vec3(0.8, 0.7, 0.5) * dif;
            return color;
        } else if (tracing_result.result == TRACING_RESULT_MAX_DISTANCE_REACHED) {
            return texture(u_skyboxTexture, ray.direction).rgb;
        } else if (tracing_result.result == TRACING_RESULT_MAX_ITERATION_COUNT_REACHED) {
            return vec3(1.0, 0.0, 0.0);
        } else {
            return vec3(0.0, 1.0, 0.0);
        }
#elif RENDER_MODE == ITERATION_COUNT
        return vec3(tracing_result.steps / u_max_iteration_count);
#elif RENDER_MODE == DEPTH
        return vec3(tracing_result.t / u_max_distance);
#endif

    }
}



#endif