#version 430 core

layout (local_size_x = 8, local_size_y = 8) in;
layout (rgba32f, binding = 0) uniform writeonly image2D outputTexture;

uniform samplerCube u_skyboxTexture;

uniform mat4 u_inv_view_proj_mat;
uniform vec3 u_position;
uniform uint u_width;
uniform uint u_height;

uniform float u_time_in_seconds;
uniform float u_epsilon;
uniform float u_max_distance;
uniform uint u_max_iteration_count;

const float PI = 3.1415926535897932384626433832795;

struct Value {
    float d; 
    int id;
};

struct Ray {
    vec3 position;
    vec3 direction;
};



float min3(float a, float b, float c) {
    return min(min(a, b), c);
}
float max3(float a, float b, float c) {
    return max(max(a, b), c);
}
float max3(vec3 a) {
    return max(max(a.x, a.y), a.z);
}
float min3(vec3 a) {
    return min(min(a.x, a.y), a.z);
}
float dot2(vec3 a) {
    return dot(a, a);
}

float Unite(float a, float b) { 
    return min(a, b);
}

Value Unite(Value a, Value b) {
    if (b.d < a.d) {
        return b;
    } 
    return a;
}

Value Unite(Value a, float b_d, int b_id) {
    if (b_d < a.d) {
        return Value(b_d, b_id);
    } 
    return a;
}

Value Unite(float a_d, Value b, int b_id) {
    return Unite(Value(a_d, b_id), b);
}

vec3 opSymX(vec3 p) {
    return vec3(abs(p.x), p.y, p.z);
}
vec3 opRepZ(vec3 p, float sz, float lo, float up) {
    return vec3(p.x, p.y, p.z - sz * clamp(round(p.z / sz), lo, up));
}

// SDF Primitives (more on https://iquilezles.org/articles/distfunctions/)
float sdRoundBox(vec3 p, vec3 b, float r) {
    vec3 q = abs(p) - b + r;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}
float sdBoxFrame(vec3 p, vec3 b, float e) {
    p = abs(p) - b;
    vec3 q = abs(p + e) - e;
    return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0), length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)), length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));
}
float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}
float sdSphere(vec3 p, float s) {
    return length(p) - s;
}
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max3(d.x, d.y, d.z), 0.0);
}

float pendulum(float t) {
    // const float q = 0.0;                   // initial angle: 0
    // const float q = 0.0004765699168668419; // initial angle: 10
    // const float q = 0.0019135945901703004; // initial angle: 20
    // const float q = 0.004333420509983138;  // initial angle: 30
    // const float q = 0.007774680416441802;  // initial angle: 40
    // const float q = 0.01229456052718145;   // initial angle: 50
    const float q = 0.017972387008967222;  // initial angle: 60
    // const float q = 0.02491506252398093;   // initial angle: 70
    // const float q = 0.03326525669557733;   // initial angle: 80
    // const float q = 0.04321391826377224;   // initial angle: 90

    float theta = 8.0 * (pow(q, 0.5) / (1.0 + pow(q, 1.0))) * cos(1.0 * t) 
                + -2.6666666666666665 * (pow(q, 1.5) / (1.0 + pow(q, 3.0))) * cos(3.0 * t) 
                + 1.6 * (pow(q, 2.5) / (1.0 + pow(q, 5.0))) * cos(5.0 * t);
    //            + -1.1428571428571428 * (pow(q, 3.5) / (1.0 + pow(q, 7.0))) * cos(7.0 * t)
    //            + 0.8888888888888888  * (pow(q, 4.5) / (1.0 + pow(q, 9.0))) * cos(9.0 * t)
    //            + -0.7272727272727273 * (pow(q, 5.5) / (1.0 + pow(q, 11.0))) * cos(11.0 * t);

    return theta;
}

Value sdf(vec3 p) {
    const float freq = 2.0;

    float first_sphere_angle = pendulum(clamp(mod(freq * u_time_in_seconds, 2.0 * PI), 0.5 * PI, 1.5 * PI) + PI);
    float last_sphere_angle = pendulum(clamp(mod(freq * u_time_in_seconds + PI, 2.0 * PI), 0.5 * PI, 1.5 * PI));

    vec3 first_sphere_pos =    vec3(0.0, -13.0 + 7.0 * cos(first_sphere_angle), -4.0 - 7.0 * sin(first_sphere_angle));
    vec3 last_sphere_pos =     vec3(0.0, -13.0 + 7.0 * cos(last_sphere_angle),   4.0 - 7.0 * sin(last_sphere_angle));
    vec3 first_cable_end_pos = vec3(0.0, -13.0 + 6.0 * cos(first_sphere_angle), -4.0 - 6.0 * sin(first_sphere_angle));
    vec3 last_cable_end_pos =  vec3(0.0, -13.0 + 6.0 * cos(last_sphere_angle),   4.0 - 6.0 * sin(last_sphere_angle));

    p = vec3(p.x, p.y + 10.0, p.z);

    Value v = Value(u_max_distance, 0);
    v = Unite(v, Value(sdBoxFrame(p + vec3(0.0, -8.0, 0.0), vec3(3.0, 5.0, 6.0), 0.1), 1));
    v = Unite(v, Value(max(sdRoundBox(p + vec3(0.0, -3.0, 0.0), vec3(4.0, 1.0, 7.0), 0.5), -(p.y - 2.99)), 0));
    v = Unite(v, Value(sdSphere(p + first_sphere_pos, 1.0), 2));
    v = Unite(v, Value(sdSphere(p + last_sphere_pos, 1.0), 2));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + first_cable_end_pos, p + vec3(3.0 - 0.1, -13.0 + 0.1, -4.0), 0.05), 4));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + first_cable_end_pos, p + vec3(-3.0 + 0.1, -13.0 + 0.1, -4.0), 0.05), 4));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + last_cable_end_pos, p + vec3(3.0 - 0.1, -13.0 + 0.1, 4.0), 0.05), 4));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + last_cable_end_pos, p + vec3(-3.0 + 0.1, -13.0 + 0.1, 4.0), 0.05), 4));
    vec3 p_rep_z = opRepZ(p, 2.0, -1.0, 1.0);
    vec3 p_rep_sym_x = opSymX(p_rep_z);
    v = Unite(v, Value(sdSphere(p_rep_z + vec3(0.0, -6.0, 0.0), 1.0), 2));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p_rep_z + vec3(0.0, -7.0, 0.0), p_rep_z + vec3(3.0 - 0.1, -13.0 + 0.1, 0.0), 0.05), 4));
    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p_rep_z + vec3(0.0, -7.0, 0.0), p_rep_z + vec3(-3.0 + 0.1, -13.0 + 0.1, 0.0), 0.05), 4));

    return v;
}

vec3 Normal(vec3 p) {
    const vec2 eps0 = vec2(0.001, 0);
    vec3 m0 = vec3(sdf(p - eps0.xyy).d, sdf(p - eps0.yxy).d, sdf(p - eps0.yyx).d);
    vec3 m1 = vec3(sdf(p + eps0.xyy).d, sdf(p + eps0.yxy).d, sdf(p + eps0.yyx).d);
    return normalize(m1 - m0);
}


void naive_sphere_tracing(Ray ray) {
    float t = 0.0;
    float d;

    uint steps = 0;
    do {
        vec3 current_position = ray.position + t * ray.direction;
        d = abs(sdf(current_position).d);
        t += d;
        steps++;
    } while (d > u_epsilon * t && t < u_max_distance && steps < u_max_iteration_count);


    if (d <= u_epsilon * t) {
        vec3 position = ray.position + t * ray.direction;
        vec3 normal = Normal(position);
        float dif = clamp(dot(normal, vec3(0.57703)), 0.0, 1.0);
        float amb = 0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0));
        vec3 color = vec3(0.2, 0.3, 0.4) * amb + vec3(0.8, 0.7, 0.5) * dif;
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
    } else if (t >= u_max_distance){
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), texture(u_skyboxTexture, ray.direction));
    } else {
        imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 0.0));
    }
}

void main() {
    if (gl_GlobalInvocationID.x >= u_width || gl_GlobalInvocationID.y >= u_height) {
        return;
    }

    vec2 normalized_pixel_coord = vec2(gl_GlobalInvocationID.xy) / vec2(u_width, u_height);
    vec2 ndc_coord = normalized_pixel_coord * 2.0 - 1.0 + (1.0 / float(u_height));
    vec4 projected_position = u_inv_view_proj_mat * vec4(ndc_coord, -1.0, 1.0);
    projected_position /= projected_position.w;
    vec3 ray_dir = normalize(projected_position.xyz - u_position);

    naive_sphere_tracing(Ray(u_position, ray_dir));
}