#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba32f, binding = 0) uniform writeonly image2D outputTexture;

uniform mat4 inv_view_proj_mat;
uniform vec3 position;
uniform float near;
uniform float far;
uniform float width;
uniform float height;
uniform samplerCube skyboxTexture;


float sdfSphere(vec3 p, vec3 sphereCenter, float radius) {
    return length(p - sphereCenter) - radius;
}

// Marching step for sphere tracing
void marchRay(vec3 rayStart, vec3 rayDir) {
    float t = 0.0;               // Distance along the ray
    float maxDist = 100.0;        // Maximum distance to march (for safety)
    float minDist = 0.001;         // Threshold for "hitting" the surface

    for (int i = 0; i < 256; i++) {  // Maximum iterations
        vec3 currentPos = rayStart + t * rayDir;

        float distToSphere = sdfSphere(currentPos, vec3(0.0, 0.0, 0.0), 1.0);
        if (distToSphere < minDist) {
            imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 0.0));
            return;
        }

        if (t > maxDist) {
            imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), texture(skyboxTexture, rayDir));
        }

        t += distToSphere; // Move by the distance to the surface
    }

    //imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(0.0, 1.0, 0.0, 0.0));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    vec2 normalizedPixel = vec2(pixelCoord) / vec2(width, height);
    normalizedPixel.x *= width / height;
    vec2 ndcCoord = normalizedPixel * 2.0f - 1.0f;
    vec4 tempPixel = vec4(ndcCoord, -1.0, 1.0);
    vec4 projectedPosition = inv_view_proj_mat * tempPixel;
    projectedPosition /= projectedPosition.w;
    vec3 rayDirection = normalize(projectedPosition.xyz - position);

    //vec2 normalizedPixel = vec2(pixelCoord) / vec2(width, height);
    //vec2 ndcCoord = normalizedPixel * 2.0f - 1.0f;
    //vec4 tempPixel = vec4(ndcCoord, -1.0, 1.0);
    //vec4 projectedPosition = inv_view_proj_mat * tempPixel;
    //projectedPosition /= projectedPosition.w;
    //vec3 rayDirection = normalize(projectedPosition.xyz - position);


    float r = ndcCoord.x;
    float g = ndcCoord.y;
    float b = 0.0;
    float a = 1.0;

    marchRay(position, rayDirection);
    //imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(r, g, b, a));
    //imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), texture(skyboxTexture, rayDirection));
}