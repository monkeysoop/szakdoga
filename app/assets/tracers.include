#ifndef TRACERS_INCLUDE
#define TRACERS_INCLUDE



#include "assets/sdf.include"
#include "assets/value.include"
#include "assets/tracing_result.include"
#include "assets/ray.include"



TracingResult naive_sphere_tracing(Ray ray, float initial_t, float initial_iteration) {
    float t = initial_t;
    float d;

    float steps = initial_iteration;
    do {
        d = abs(sdf(ray.position + t * ray.direction).d);
        steps += 1.0;
        t += d;
    } while (d > u_epsilon * t && t < u_max_distance && steps < u_max_iteration_count);

    if (d <= u_epsilon * t) {
        return TracingResult(TRACING_RESULT_HIT, t, steps);
    } else if (t >= u_max_distance){
        return TracingResult(TRACING_RESULT_MAX_DISTANCE_REACHED, u_max_distance, steps);
    } else {
        return TracingResult(TRACING_RESULT_MAX_ITERATION_COUNT_REACHED, t, u_max_iteration_count);
    }
}

TracingResult relaxed_sphere_tracing(Ray ray, float initial_t, float initial_iteration) {
    float next_d;
    float next_t = initial_t;

    float d = 0.0;
    float t = initial_t;

    float steps = initial_iteration;

    do {
        next_d = abs(sdf(ray.position + next_t * ray.direction).d);
        steps++;

        if ((d + next_d) < u_relaxed_step_multiplier * d && next_t != (t + d)) {
            next_t = t + d;
        } else {
            t = next_t;
            d = next_d;

            next_t = next_t + u_relaxed_step_multiplier * next_d;
        }
    } while (d > u_epsilon * t && t < u_max_distance && steps < u_max_iteration_count);
 
    if (d <= u_epsilon * t) {
        return TracingResult(TRACING_RESULT_HIT, t, steps);
    } else if (t >= u_max_distance){
        return TracingResult(TRACING_RESULT_MAX_DISTANCE_REACHED, u_max_distance, steps);
    } else {
        return TracingResult(TRACING_RESULT_MAX_ITERATION_COUNT_REACHED, t, u_max_iteration_count);
    }
}

TracingResult enhanced_sphere_tracing(Ray ray, float initial_t, float initial_iteration) {
    float next_d;
    float next_t = initial_t;

    float d = 0.0;
    float t = initial_t;

    float s = 0.0;
    float next_s = 0.0;

    float steps = initial_iteration;

    do {
        next_d = abs(sdf(ray.position + next_t * ray.direction).d);
        steps++;

        if ((d + next_d) < next_s && next_t != (t + d)) {
            next_s = d;
            s = d;
            
            next_t = t + d;
        } else {
            next_s = next_d + u_enhanced_step_multiplier * next_d * ((-1.0 * d + next_d + s) / (d - next_d + s));
            next_s = clamp(next_s, next_d, u_enhanced_max_step_factor * next_d);
            
            t = next_t;
            d = next_d;
            
            s = next_s;

            next_t = next_t + next_s;
        }
    } while (d > u_epsilon * t && t < u_max_distance && steps < u_max_iteration_count);

    if (d <= u_epsilon * t) {
        return TracingResult(TRACING_RESULT_HIT, t, steps);
    } else if (t >= u_max_distance){
        return TracingResult(TRACING_RESULT_MAX_DISTANCE_REACHED, u_max_distance, steps);
    } else {
        return TracingResult(TRACING_RESULT_MAX_ITERATION_COUNT_REACHED, t, u_max_iteration_count);
    }
}

TracingResult SphereTracing(Ray ray, float initial_t, float initial_iteration) {
#if SPHERE_TRACING_TYPE == NAIVE
    return naive_sphere_tracing(ray, initial_t, initial_iteration);
#elif SPHERE_TRACING_TYPE == RELAXED
    return relaxed_sphere_tracing(ray, initial_t, initial_iteration);
#elif SPHERE_TRACING_TYPE == ENHANCED
    return enhanced_sphere_tracing(ray, initial_t, initial_iteration);
#endif
}



#endif