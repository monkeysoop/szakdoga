#version 430 core

layout (local_size_x = 8, local_size_y = 8) in;
layout (r32f, binding = 0) uniform readonly image2D distancesTexture1;
layout (r32f, binding = 1) uniform writeonly image2D distancesTexture2;
layout (rgba32f, binding = 2) uniform readonly image2D precomputedConesTexture;


uniform mat4 u_inv_view_mat;
uniform vec3 u_position;
uniform uint u_width;
uniform uint u_height;

uniform float u_time_in_seconds;
uniform float u_epsilon;
uniform float u_max_distance;
uniform uint u_max_iteration_count;

uniform bool u_first_pass;


#include "assets/sdf.include"


struct Ray {
    vec3 position;
    vec3 direction;
};



void cone_tracing(Ray ray, float initial_t, float cone_scale) {
    float t = initial_t;

    float d;
    float step_size = u_epsilon;

    uint steps = 0;
    do {
        vec3 current_position = ray.position + t * ray.direction;
        d = abs(sdf(current_position).d);
        step_size = d - cone_scale * t;
        if (step_size < u_epsilon) {
            break;
        }
        t += step_size;
        steps++;
    } while (t < u_max_distance && steps < u_max_iteration_count);

    if (step_size < u_epsilon) {
        imageStore(distancesTexture2, ivec2(gl_GlobalInvocationID.xy), vec4(t));
    } else if (t >= u_max_distance) {
        imageStore(distancesTexture2, ivec2(gl_GlobalInvocationID.xy), vec4(u_max_distance));
    } else if (steps >= u_max_iteration_count) {
        imageStore(distancesTexture2, ivec2(gl_GlobalInvocationID.xy), vec4(t));
    } else {
        imageStore(distancesTexture2, ivec2(gl_GlobalInvocationID.xy), vec4(-2.0));
    }
}

void main() {
    if (gl_GlobalInvocationID.x >= u_width || gl_GlobalInvocationID.y >= u_height) {
        return;
    }

    vec4 precomputed = imageLoad(precomputedConesTexture, ivec2(gl_GlobalInvocationID.xy));

    vec4 ray_target = u_inv_view_mat * vec4(precomputed.xyz, 1.0);
    vec3 ray_dir = normalize(ray_target.xyz - u_position);
    
    float cone_scale = precomputed.w;

    float initial_t = 0.0;
    if (!u_first_pass) {
        initial_t = imageLoad(distancesTexture1, ivec2(gl_GlobalInvocationID.xy / 2)).r;

        if (initial_t >= u_max_distance || initial_t < 0.0) {
            imageStore(distancesTexture2, ivec2(gl_GlobalInvocationID.xy), vec4(initial_t));
            return;
        }
    }

    cone_tracing(Ray(u_position, ray_dir), initial_t, cone_scale);
}