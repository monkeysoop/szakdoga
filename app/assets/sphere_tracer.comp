#version 430 core

layout (local_size_x = 8, local_size_y = 8) in;
layout (rgba32f, binding = 0) uniform writeonly image2D outputTexture;

uniform samplerCube u_skyboxTexture;

uniform mat4 u_inv_view_proj_mat;
uniform vec3 u_position;
uniform uint u_width;
uniform uint u_height;

uniform float u_time_in_seconds;
uniform float u_epsilon;
uniform float u_max_distance;
uniform float u_max_iteration_count;

uniform float u_relaxed_step_multiplier;
uniform float u_enhanced_step_multiplier;
uniform float u_enhanced_max_step_factor;


#define NEWTONS_CRADLE 0
#define CAR 1
#define TEMPLE 2

#define NORMAL 0
#define ITERATION_COUNT 1
#define DEPTH 2

#define NAIVE 0
#define RELAXED 1
#define ENHANCED 2

#define SDF_SCENE @SDF_SCENE@
#define RENDER_MODE @RENDER_MODE@
#define SPHERE_TRACING_TYPE @SPHERE_TRACING_TYPE@


#include "assets/renderer.include"
#include "assets/ray.include"



void main() {
    if (gl_GlobalInvocationID.x >= u_width || gl_GlobalInvocationID.y >= u_height) {
        return;
    }

    vec2 normalized_pixel_coord = vec2(gl_GlobalInvocationID.xy) / vec2(u_width, u_height);
    vec2 ndc_coord = normalized_pixel_coord * 2.0 - 1.0 + (1.0 / float(u_height));
    vec4 projected_position = u_inv_view_proj_mat * vec4(ndc_coord, -1.0, 1.0);
    projected_position /= projected_position.w;
    vec3 ray_dir = normalize(projected_position.xyz - u_position);

    vec3 color = Render(Ray(u_position, ray_dir), 0.0, 0.0);

    imageStore(outputTexture, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}