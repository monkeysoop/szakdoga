\chapter{Fejlesztői dokumentáció}
\label{ch:dev_docs}

\section{Megoldási terv}

A szakdolgozatomban két különböző főbb feladattal foglalkoztam, A különböző távolságfüggvények megjelenítéséhez használt gömbkövetési módszerek implementálásával, és ezek tesztelésével, ami a különböző módszerek teljesítményének és vizuális minőségének a mérésével és összehasonlításával foglalkozik.

Az előbbi lényege, hogy valós időben, egy kiválasztott távolságfüggvényt, az egyik módszerrel masszívan párhuzamosan megjelenítse. A program lehetőséget ad, hogy a kamerával körbejárhassuk a kiválasztott távolságfüggvényt, a különböző paramétereket valós időben módosíthassuk.

A tesztelés egy szinte automatikus folyamat, amely elindítása előtt, megadhatjuk, hogy mekkora iteráció limiteket szeretnénk tesztelni, beállíthatjuk a kamera pozícióját és egyéb a megjelenítéséhez és teszteléshez tartozó paramétereket (az egyszerűség és ismételhetőség kedvéért az idő automatikusan 0-ra van állítva a tesztek alatt). Miután elindult a teszt az a különböző módszerek mindegyikét egy állítható paraméter szerint többször lefuttatja, majd az egy kirajzolásra jutó átlagos időket fájlba kiírja, a kirajzolás eredményeit elmenti képekként, ezentúl még a pixelekre eső iteráció számok által alkotott képeket is elmenti. Az elmentett png képeket (azért png, mert SDL2 támogatja és veszteségmentes) és a mért időket majd jupiter notebook-ok segítségével elemzem, erről bővebben lásd a(z) \ref{se:performance_visual_testing}. fejezetet.

A program ezen túl tartalmaz még egység teszteket is.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{plantuml/usecase.png}
	\caption{Az ábrán a program használati eset diagramja látható.}
\end{figure}

\section{A program architektúrája}

Az applikáció áll egy \texttt{main.cpp} C++ fájlból, egy statikus C++ könyvtárból és GLSL „compute” shader fájlokból.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/classdiagram.png}
	\caption{A program osztálydiagramja.}
\end{figure}

A \texttt{Texture2D} osztály egy RAII (Resource Allocation Is Initialization) absztrakció egy OpenGL 2 dimenziós textúra köré, hasonlóan a \texttt{Skybox} osztály egy „cubemap”-et absztraktál. A \texttt{Framebuffer} osztály, ahogy a neve is mondja, egy OpenGL „framebuffer”-t absztraktál, de itt helyezkedik el, a képernyő fotó készítő logika is. A \texttt{CompShader} osztály GLSL „compute” shader-t hoz létre. A \texttt{Framebuffer} és \texttt{CompShader} osztály is követi a RAII-t. A \texttt{Camera} és \texttt{CameraManipulátor} osztályok a kamera projekciós és nézeti mátrixok lekérdezését, billentyűzet és egér események általi módosítását végzik. Az \texttt{App} osztály meg ezeket összekötve adja az applikációt.

\subsection{Az \texttt{App} osztály}

Az App osztály egyik főbb feladata a grafikus felület kezelése. A felület túlnyomó részét egyszerű ImGui lebegőpontos és egész típusú csúszkák valamint rádiógombok teszik ki, amik az \texttt{App} osztály privát változóit módosítják, a változók és rövid leírásuk:

\begin{itemize}
	\item \textbf{\texttt{m\_sdf\_scene}:} a kiválasztott távolságfüggvényt adja meg
	\item \textbf{\texttt{m\_render\_mode}:} a kiválasztott kirajzolási módszert tárolja
	\item \textbf{\texttt{m\_tracing\_type, m\_sphere\_tracing\_type, m\_cone\_trace\_sphere\_tracing\_type, m\_cone\_trace\_final\_sphere\_tracing\_type}:} a gömbkövetési módszert (al módszert is) határozzák meg
	\item \textbf{\texttt{m\_initial\_cone\_size}:} kezdeti kúpméret pixelben megadva (például, ha 8, akkor az azt jelenti, hogy 8x8 pixel a kúpok mérete a kezdetben)
	\item \textbf{\texttt{m\_epsilon}:} gömbkövetésnél használt paraméter túl kicsi lépések detektálására
	\item \textbf{\texttt{m\_max\_distance}:} távolság, amin túl a program úgy tesz, mintha a sugár a skybox-ot találta volna el
	\item \textbf{\texttt{m\_max\_iteration\_count}:} limit a gömbkövetés iteráció számaira
	\item \textbf{\texttt{m\_relaxed\_step\_multiplier, m\_cone\_trace\_relaxed\_step\_multiplier, m\_cone\_trace\_final\_relaxed\_step\_multiplier}:} a relaxált gömbkövetés lépés mértékét beszorzó skalár
	\item \textbf{\texttt{m\_enhanced\_step\_multiplier, m\_cone\_trace\_ enhanced \_step\_multiplier, m\_cone\_trace\_final\_ enhanced \_step\_multiplier}:} a javított gömbkövetés lépés mértékét beszorzó skalár
	\item \textbf{\texttt{m\_enhanced\_max\_step\_factor, m\_cone\_trace\_enhanced\_max\_step\_factor, m\_cone\_trace\_final\_enhanced\_max\_step\_factor}:} a javított gömbkövetés lépés mértékét limitáló skalár
	\item \textbf{\texttt{m\_cone\_trace\_intermediate\_epsilon}:} m\_epsilon-hoz hasonló, de a kúpkövetésnél használt
	\item \textbf{\texttt{m\_benchmark\_baseline\_iteration\_count}:} limit a tesztelésnél használt referencia kép iteráció számaira
	\item \textbf{\texttt{m\_benchmark\_min\_iteration\_count, m\_benchmark\_max\_iteration\_count, m\_benchmark\_iteration\_count\_spacing}:} rendre a tesztelésnél használt iteráció limitek alsó, felső korlátja, és hogy mekkora közönként vannak (például rendre 10, 70, 20 azt jelenti, hogy 10, 30, 50, 70 iteráció limitekkel fogja lefuttatni a különböző módszereket tesztelésnél)
	\item \textbf{\texttt{m\_benchmark\_performance\_number\_of\_runs}:} a tesztelésnél megadja, hogy egy módszert, egy iteráció limittel hányszor fogja lefuttatni egymás után, minél nagyobb, annál pontosabb lesz az átlag
	\item \textbf{\texttt{m\_shadow\_penumbra, m\_shadow\_intesity}:} az árnyékok penumbra részét és intenzitását tárolja el
	\item \textbf{\texttt{m\_ao\_multiplier\_attenuation, m\_ao\_step\_size, m\_ao\_strength}:} az ambiens kitakarás számításánál használt paraméterek, rendre: erősségének elhalása (ahogy iterál), iterálás lépésköze, erősségét szorzó skalár
	\item \textbf{\texttt{m\_shadow\_max\_iteration\_count, m\_ao\_max\_iteration\_count}:} iteráció limit az árnyékok és ambiens kitakarás kiszámításához
	\item \textbf{\texttt{m\_ambient\_strength}:} ambiens fény ereje
	\item \textbf{\texttt{m\_reflection\_attenuation}:} a tükröződéseknél használt extra elhalást imitáló skalár
	\item \textbf{\texttt{m\_max\_number\_of\_reflections}:} a maximum tükröződések számának limitje
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/App_class_diagram.png}
	\caption{Az \texttt{App} osztály osztálydiagramja.}
\end{figure}

\subsection{A \texttt{Camera} osztály}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/Camera_class_diagram.png}
	\caption{A \texttt{Camera} osztály osztálydiagramja.}
\end{figure}

\subsection{A \texttt{CameraManipulator} osztály}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/CameraManipulator_class_diagram.png}
	\caption{A \texttt{CameraManipulator} osztály osztálydiagramja.}
\end{figure}

\subsection{A \texttt{CompShader} osztály működése, a shaderek fordítása}

A \texttt{CompShader} osztály egy szimpla RAII absztrakciónál bonyolultabban működik, mivel a GLSL nyelv önmagába a \texttt{\#include} preprocesszor makrót nem támogatja, nyilvánvaló okok miatt, ezért hosszabb shaderek fejlesztése és karbantartása problémás tud lenni, ezért az osztály a konstruktorába kap egy listát shader fájl útvonalakkal:

\lstset{caption={Az egyik használt shader konstruktorának az egyik paramétere, egy \texttt{std::vector<std::filesystem::path>} látható, tele include fájl útvonalakkal.}, label=src:cpp1, linewidth=0.9\linewidth, xleftmargin=0.07\linewidth}
\begin{lstlisting}[language={C++}]
{
    std::filesystem::path{"assets"} / "ray.include",
    std::filesystem::path{"assets"} / "value.include", 
    std::filesystem::path{"assets"} / "sdf.include",
    std::filesystem::path{"assets"} / "sdf_newtons_cradle.include", 
    std::filesystem::path{"assets"} / "sdf_car.include", 
    std::filesystem::path{"assets"} / "sdf_temple.include", 
    std::filesystem::path{"assets"} / "sdf_primitives.include", 
    std::filesystem::path{"assets"} / "tracing_result.include",
    std::filesystem::path{"assets"} / "tracers.include", 
    std::filesystem::path{"assets"} / "renderer.include",
}
\end{lstlisting}

amikből kiválogatva másolja be a megfelelő fájl tartalmát a

\lstset{caption={Példa az include "makró" használatára.}, label=src:cpp2, linewidth=0.9\linewidth, xleftmargin=0.07\linewidth}
\begin{lstlisting}[language={C++}]
#include "assets/ray.include"
\end{lstlisting}

helyére hasonlóan a C preprocesszorhoz. Ezenkívül még a cmake-ben található fájl konfigurációhoz hasonlóan (\texttt{configure\_file}) van lehetőség statikus paramétereket megadni fordítás során

\lstset{caption={Példa úgynevezett "in" paraméterekre.}, label=src:cpp3, linewidth=0.9\linewidth, xleftmargin=0.07\linewidth}
\begin{lstlisting}[language={C++}]
#define SDF_SCENE @SDF_SCENE@
#define RENDER_MODE @RENDER_MODE@
#define SPHERE_TRACING_TYPE @SPHERE_TRACING_TYPE@
\end{lstlisting}

Az osztály ezenkívül lehetőséget ad, hogy ezeket a paramétereket dinamikusan módosítsuk, amik a kód újra fordításához vezetnek. Eredetileg \texttt{uniform} változókat és \texttt{switch case} -eket használtam nagyobb kódrészek között történő váltogatásra, például kiválasztani, hogy melyik SDF függvény hívódjon meg, ez a módszer viszont problémás volt, egyrészt lassabb lett tőle a program, mintha preprocesszor makrókkal oldottam volna meg (ez kevésbé okozott gondot, mivel az optimalizáló elég jól tudja kezelni az \texttt{uniform} változókat, főleg elágazások terén) a nagyobbik probléma az volt, hogy ez meglehetősen hosszú akadozásokat okozott (egyes esetekben 5-10 másodperc), amikor az \texttt{uniform} értéke megváltozott. A problémán nem segített, ha újrafordítottam a shadert minden egyes alkalommal, hiszen maga a fordítás is meglehetősen lassú volt (ez részben a nagy shaderek problémája). Az okot nem nagyon kutattam, de ha jól tudom a shadereket ha nem is teljesen, de részlegesen újra fordítják/optimalizálják, amikor egy \texttt{uniform} értéke megváltozik, ami kombinálva a lassú fordítási időkkel okozhatta a problémát. A megoldás így az lett, hogy fordítás alatt felparaméterezek \texttt{\#define} makrókat adom oda \texttt{\#if}/\texttt{\#elif}/\texttt{\#endif} makróknak, így a fordító gyorsan eltudja dobni a kód nagyrészét, ezzel elérve a gyors fordítást és az optimális teljesítményt.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/CompShader_class_diagram.png}
	\caption{A \texttt{CompShader} osztály osztálydiagramja.}
\end{figure}

Az osztály \texttt{m\_shader\_source\_code} privát változója eltárolja a programhoz tartozó forrás kódot, az \texttt{\#include} preprocesszor makró utáni, de az „in” változók (\texttt{@változó@}) konfigurálása előtti állapotban, a forráskód eltárolása azért hasznos, mert ha a konfigurációt megváltoztatnánk és a programot ezzel újra fordítanánk, akkor így nem kell a fájlt/fájlokat újra beolvasni.

Az osztály \texttt{m\_currently\_used\_id} privát változója azért kiemelendő, mert a fejlesztés alatti hibák kiszűrésénél nagyon hasznos volt számomra, figyelmeztet, ha egy olyan \texttt{uniform} változó helyét kérjük le, ami nem az aktív programhoz (shader) tartozik.

\subsection{A \texttt{Framebuffer} osztály, képernyőkép készítés}

A Framebuffer osztály lehetőséget ad, hogy egy megadott útvonalba lementsük a buffer tartalmát az SDL könyvtár (SDL\_image) segítségével PNG formátumba, mivel OpenGL-ben a (0,0) koordináta bal alul van, míg az SDL a bal föntit használja, így, ha nem tükrözzük a felületet, akkor fejjel lefelé lévő képeket kapnánk, ezért kell megfordítani a képet. Az SDL3 könyvtár erre már beépített függvényt kínál, míg az SDL2 nem (a program írása alatt az SDL3 könyvtár még fejlesztés alatt állt).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/Framebuffer_class_diagram.png}
	\caption{A \texttt{Framebuffer} osztály osztálydiagramja.}
\end{figure}

\subsection{A \texttt{Skybox} osztály}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/Skybox_class_diagram.png}
	\caption{A \texttt{Skybox} osztály osztálydiagramja.}
\end{figure}

\subsection{A \texttt{Texture2D} osztály}

A konstruktorba paraméterül meg lehet adni a „mipmap” szintek számát (opcionális), ha nincs konkrét érték megadva, akkor értéke 1 lesz, azaz egy szimpla 2 dimenziós sík textúra lesz. Többszintű textúrákat a kúpkövetésnél használom a megtett távolságok eltárolására a rétegek között, ahol mindig négyszereződik a szálak száma és azzal együtt az elvárt textúra mérete is.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{plantuml/Texture2D_class_diagram.png}
	\caption{A \texttt{Texture2D} osztály osztálydiagramja.}
\end{figure}


\subsection{A program mappa struktúrája}

A kód nagyrésze az \texttt{app} mappa alatt található, itt helyezkedi el a belépési pont (\texttt{app/main.cpp}) is, az \texttt{app/core} mappában található az összes többi C++ forráskód, \texttt{app/core/src} a \texttt{*.cpp} fájlokat, \texttt{app/core/include} a \texttt{*.hpp} és \texttt{*.h} fájlokat tartalmaz, az \texttt{app/core/tests} az egységtesztekhez szükséges fájlokat. Az \texttt{app/assets} tartalmazza a \texttt{*.comp} és \texttt{*.include} GLSL forrás fájlokat. Az \texttt{app/tests} tartalmazza az összehasonlításhoz tartozó python fájlokat. A \texttt{docs} mappa a szakdolgozathoz felhasznált képeket, uml diagrammokat és geogebra \texttt{*.ggb} fájlokat tartalmazza. A \texttt{scripts} mappa segéd Bash scripteket tartalmaz (program fordításához, csomagok letöltéséhez, teszteléshez). A \texttt{subprojects} egy a meson által használt mappa, amelyben az ImGui SDL2 és OpenGL-el vett kapcsolat létrehozásához vannak fájlok.

\section{Futtatási környezet}

A programot C++ nyelven és GLSL shader nyelven írtam, a mérések eredményeit python jupiter nootbook segítségével hasonlítom össze. C++ 17 és GLSL 430-as verziókat használom, a program OpenGL API-t használ GLEW keretrendszerrel és SDL2 könyvtárral együtt. A GUI-t ImGui segítségével hoztam létre. Az egység tesztek pedig googletest keretrendszerrel lettek létrehozva. A programot Linux Mint 22 alatt és Visual Studio Code-ban fejlesztettem, a használt csomagok kezeléséről conan (2-es verzió) gondoskodik, a projektet pedig meson segítségével lehet fordítani.


\section{Meson és conan}

Megemlítendő, hogy az imgui conan csomag nem tartalmazza az SDL2/OpenGL könyvtárakkal való együttműködéshez szükséges úgynevezett "imgui bindigs"-okat, ezeket álltalában git submodul-ként szokták pótolni, de én egy másik utat választottam: a conan csomagjában megtalálhatóak a szükséges fájlok, ezeket én kimásolom (conan-nal) és subproject-ként építem meson-nal manuálisan.

\section{Shaderek}

A shaderek az \texttt{app/assets} mappában találhatóak (a teszteléshez szükségesek az \texttt{app/core/tests/assets} mappában), ugyanitt helyezkednek el a skybox-hoz szükséges képek is.

A \texttt{COMP} „típusú” fájlok (\texttt{*.COMP}) meg az azok által használt \texttt{INCLUDE} (\texttt{*.INCLUDE}), ezek mindketten GLSL szintaxist használnak, viszont az \texttt{INCLUDE} fájlok nem tartalmazzák a \texttt{\#version} tag-et, így technikailag nem GLSL fájlok, míg a \texttt{COMP} fájlok igen.

Mivel az egyedi preprocesszorom a CompShader osztályban a C nyelvben találhatóhoz hasonlóan működik így az \texttt{INCLUDE} fájlok tartalmaznak „include guard”-okat.

\section{Kúpok előre történő kiszámolása}

A kúpok irányai és méreteik (alapjának sugara egység távolságban) előre ki vannak számolva és egy textúrában eltárolva a program indításakor majd azt frissíti minden, képernyő átméretezésekor, kúpkövetés kezdeti kúpméretének módosításakor és az egér görgőjével történő nagyításakor. Mivel előre nem lehet tudni a nézeti mátrixot így valójában nem a végleges irány van meghatározva, hanem az inverz projekciós mátrix által beszorzott irány van, így a kúp mérete meghatározható, de a tényleges irányhoz még az inverz nézeti mátrixxal is be kell szorozni, de ez egy relatív gyors művelet.

\section{SDF-ek közti váltogatás}

A szakdolgozat célja nem egy jól kidolgozott SDF nézegető program fejlesztése volt, így például nincs mód arra, hogy különböző SDF-eket dinamikusan hozzáadjunk (meglévők között lehet dinamikusan váltogatni). Jelenlegi megoldás szerint az \texttt{sdf.INCLUDE} fájlban egy preprocesszor makró dönti el, hogy melyik SDF legyen kiválasztva, amit dinamikusan (a shader újrafordul) lehet módosítani a grafikus felületen keresztül

\lstset{caption={Ez a preprocesszor elágazás dönt, hogy melyik SDF függvény aktív egy adott pillanatban.}, label=src:cpp4, linewidth=0.9\linewidth, xleftmargin=0.07\linewidth}
\begin{lstlisting}[language={C++}]
#if SDF_SCENE == NEWTONS_CRADLE
    #include "assets/sdf_newtons_cradle.include"
#elif SDF_SCENE == CAR
    #include "assets/sdf_car.include"
#elif SDF_SCENE == TEMPLE
    #include "assets/sdf_temple.include"
#elif SDF_SCENE == PRIMITIVES
    #include "assets/sdf_primitives.include"
#endif
\end{lstlisting}

Maguk az SDF függvények külön fájlokban vannak és egy fix szignatúrájú függvényt kell, hogy tartalmazzanak

\lstset{caption={Az autó SDF függvénye (részlet).}, label=src:cpp5, linewidth=0.9\linewidth, xleftmargin=0.07\linewidth}
\begin{lstlisting}[language={C++}]
Value sdf(vec3 p) {
    p.y += 0.2;

    float car = sdCar(p).x * 0.8;
    vec3 wp = p-vec3(0,0,.14);
    wp.xz = abs(wp.xz);
    wp-=vec3(.7383, .365, 1.5);
    
    if(p.z>0.) wp.xz *= Rot(.3*sign(p.x));
    float wheel = sdWheel(wp).x;
    
    return Value(min(car, wheel), 4);
}
\end{lstlisting}

A preprocesszor makró egyik nagy előnye, hogy sok függvény név ütközést elkerül az SDF függvények között (gyakran azonos néven definiálnak segéd függvényeket, vagy például a $\pi$ konstanst), ez azért fontos, mert így kis módosítás kellett az internetről szerzett SDF függvények integrálásakor.

\section{Különböző nézeti módok}
\label{se:rendering_modes}

A nézeti módok között dinamikusan lehet váltogatni a grafikus felületen keresztül. A kúpkövetésnél az iterációk száma pixelekre van átlagolva, például, ha van egy 8x8-as kúpunk, ami tett 24 iterációt és ez a kúp felbomlik 4 darab 4x4 es kúpra, akkor mindegyik kúp úgymond 6 iterációt tett.

\begin{itemize}
	\item \textbf{Normál:} Ez egy BRDF alapon rekurzívan követi a sugarat, majd a kapott színt jeleníti meg, minden ütközésnél fog indítani sugarakat a fényforrás felé a puha árnyékok miatt és egy sugarat a normál mentén az ambiens kitakarás (ambient occlusion) közelítése céljából.
	\item \textbf{Iterációk száma:} A Normál mód kiszámítása alatt a sugár mentén tett iterációk száma (vagyis az ahhoz szükséges SDF hívások számai, kivéve az ambiens kitakarás, puha árnyékok és normál vektor kiszámításához szükséges függvényhívásokat). Ez az érték a paraméterül kapott iteráció szám limittel van elosztva, így a kapott „szín” 0 és 1 közé lesz beszorítva. Kúpkövetésnél ez a pixelekre eső átlag lesz.
	\begin{figure}[H]
    	\centering
    	\includegraphics[width=0.9\textwidth,keepaspectratio]{gui/iter_count.png}
    	\caption{A Newton ingája SDF iteráció számai láthatóak, minnél világosabb annál nagyobb az iteráció szám.}
    \end{figure}
    \item \textbf{SDF hívások száma:} A Normál mód összes SDF hívásainak száma elosztva egy felső korláttal, úgy, hogy az eredmény garantáltan 0 és 1 között legyen.
	\item \textbf{Debug:} Ebben a módban a sugarak csakis az első ütközésig mennek vagy amíg a feltételek igazak (max iteráció szám, max távolság), ha ütközik, akkor egy nagyon egyszer módon egy szürke árnyalatot kap, ha átlépi a max távolságot, akkor a skybox színét kapja, ha pedig az iteráció limitet haladja meg, akkor pedig egy fix piros színt kap.
	\begin{figure}[H]
    	\centering
    	\includegraphics[width=0.9\textwidth,keepaspectratio]{gui/debug.png}
    	\caption{A Newton ingájának SDF-je látható Debug módba.}
    \end{figure}
	\item \textbf{Debug mód iteráció száma:} Itt a 0 és 1 közé beszorított pixelenként megtett iteráció számok (az első ütközésig) lesznek.
    \item \textbf{Mélység:} Szimplán a mélységet fogja kirajzolni.
\end{itemize}
