\chapter{Elmélet}
\label{ch:theory}

\section{SDF}

A távolságfüggvények (Distance Function) a tér minden pontjához hozzárendeli az implicit felület legközelebbi pontjától vett távolságot. Az előjeles távolságfüggvény (Signed Distance Function) annyiban különbözik, hogy negatív értékeket (-1 szeresét) rendel hozzá a felület belsejében lévő pontokhoz, tehát, ha a pont a felületen kívül van, akkor pozitív a távolság, ha a felületen van, akkor nulla és negatív, ha a belsejében van.

\section{Sphere Tracing}

A gömbkövetés (sphere tracing) a sugárkövetések egyik változata, melynek célja a sugár és az előjeles távolságfüggvény felület metszéspontjának megtalálása. Az alapmódszer ezt úgy éri el, hogy a sugár kiinduló pontjából a sugár mentén haladva először kiértékeli az SDF-et az adott pontból, majd a kapott távolságnyit lép előre, és ezt ismétli mindaddig, amíg három feltétel igaz:

\begin{itemize}
	\item a lépés mértéke nagyobb, mint egy választott érték: epszilon (általában kicsi: 0.001) szorozva a megtett úttal
	\item a kiindulási pontjától vett távolság kisebb, mint egy választott limit (pl.: 1000)
	\item az iterációk száma nem lépett át egy megadott határt
\end{itemize}

A gömbkövetés lényege, hogy a pixel közepéből induló sugár mentén keressük a felülettel való metszési pontot.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/sphere_tracing/sphere_tracing_0.png}
	\caption{Az ábrán a hagyományos gömbkövetés látható, ahol most az átláthatóság kedvéért csak kettő sugár van berajzolva, az első sugár eltalálja az SDF-et (piros testek), míg a második nem.}
\end{figure}

\section{Relaxed és Enhanced Sphere Tracing}

A relaxált és javított gömbkövetés úgy próbálja az alap gömbkövetést gyorsítani, hogy ahelyett, hogy az SDF kiértékeléséből származó távolságnyit lépne, helyette annak többszörösét lépi, majd a lépést követő SDF kiértékelés távolságával ellenőrzi, hogy nem lépett-e túl sokat, ha nem, akkor halad tovább, viszont, ha igen, akkor visszamegy az előző pontra, és csak egyszeresét lépi. Ezzel ugyanazt a távolságot potenciálisan kevesebb iterációval vagy ugyanannyi iterációval nagyobb távolságot megtéve.

A relaxált a lépés méretét szorzó skalárt egy fix konstansból kapja.

A javított gömbkövetés a két megelőző lépés pontja közötti távolság (azaz az előző lépés mértéke) és a két pont SDF távolság felhasználásával becsüli a szorzót. Ezt a szorzót ezen túl még, beszorozza egy 0.0 és 1.0 közötti fix paraméterrel (pl.: 0.9), ezzel csökkentve a visszalépések számát, amiket kicsi numerikus hibák okoznának, majd még beszorítja (clamp) 1.0 és egy paraméterül megadott konstans közé (pl.: 10.0), ez extrém esetek elkerülése miatt van.

\section{Kúpkövetés}

A cél itt is az alap gömbkövetés gyorsítása, viszont a módszer más, az algoritmus lényege, ahelyett, hogy a képernyő minden pixeléből külön sugarat indítana, helyette szomszédos pixeleket egyesítő kúpokat használ, és azok mentén iterál addig, amíg három feltétel igaz:

\begin{itemize}
	\item a lépés mértéke, ami itt nem az adott pont SDF értéke, hanem az, mínusz a pontbeli kúp sugara nagyobb, mint egy fix epszilon (az alap módszernél nagyobb pl.: 0.02) paraméter
	\item nem lépett át egy max távolság határt
	\item az iterációk száma a limit alatt van
\end{itemize}

\subsection{A kúpok méretének és irányának meghatározása}

A megoldandó probléma: egy térbeli téglalap kamera szemszögéből kiinduló gúlájának, megtaláljuk a lehető legkisebb az azt körbe ölelő kúpját. Az implementációban csakis négyzeteket használok, amik több pixelből álló „blokkokat” reprezentálnak.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing_3D/cone_tracing_3D_0.png}
	\caption{Az ábrán egy térbeli négyzet (lila), egy kamera és egy gúla (barna) látható.}
\end{figure}

A kúp megtalálását át lehet fogalmazni, úgy, hogy a téglalap/négyzet sarkait egy gömb felületére vetítjük

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing_3D/cone_tracing_3D_1.png}
	\caption{Az ábrán egy piros gömb felületére a kamera szemszögéből vetített négyzet látható.}
\end{figure}

majd a vetített pontok magába foglaló lehető legkiseb kört keressük. Valójában a kör origója érdekes, abból a sugarat könnyedén kiszámolhatjuk. A naiv megoldás az lenne, ami az eredeti téglalap/négyzet közepét vetíti a gömb felületére és használja azt a kör/kúp közepének/irányának.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing_3D/cone_tracing_3D_2.png}
	\caption{Az ábrán kék körként látható a naiv megoldás.}
\end{figure}

Egy egyszerű trükkel szinte optimális megoldást kaphatunk, lényegében a vetítés utáni hosszabb átló közepét használja a kör/kúp közepének/irányának. Ez nem mindig vezet az optimális eredményhez, mivel az átló és a kamerához közelebbi vetített pont által alkotott háromszög lehet hegyesszögű a kamerához közelebbi pontjánál, de bőven elég jó közelítés.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing_3D/cone_tracing_3D_3.png}
	\caption{Az ábrán a kék kör a naiv, míg zöld a szinte optimális megoldás.}
\end{figure}

A hosszabb átlót egyszerűen ki tudjuk számolni, abból, hogy a képernyő melyik negyedében vagyunk.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{geogebra/cone_tracing_3D/cone_tracing_3D_4.png}
	\caption{Az ábrán a piros pont a kamera/képernyő közepe, a négyzetek maguk a pixelek és azok az átlók vannak még berajzolva, amelyek a vetítés után hosszabbak lesznek.}
\end{figure}

Ez a módszer nem mindig vezet az optimális irány megtalálásához, de a naiv megoldásnál rosszabb eredményt nem fog adni.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio]{gui/cone_error_1.png}
    \vspace{10pt}
    \includegraphics[width=0.9\textwidth,keepaspectratio]{gui/cone_error_2.png}
    \caption{Az ábrán piros pixelek jelölik azokat a pontokat, ahol ez a közelítés nem vezetett az optimális eredményhez, vagyis a háromszög kamerához közelebbi csúcsai hegyesszögűek.}
\end{figure}

\subsection{Kúpkövetés 2D példa}

Az elkövetkezendő ábrák segítségével vizualizálom a kúpkövetés működését ebben az alfejezetben.
\begin{itemize}
	\item A piros alakzatok alkotják a távolságfüggvényt.
	\item Lila kúp a kamerából kiinduló „gúla”, aminek az irányát szaggatott vonal fogja jelölni.
	\item A kék és piros pontok a „pixelek” határait és közepeit jelölik, a példában a képernyő 4 pixelből fog állni.
    \item A narancssárga pontok a távolságfüggvény kiértékelésének pontjai.
    \item A kék vonalak az aktuális pontbeli sugarát vizualizálják a kúpnak, ott, ahol a távolságfüggvényt kiértékeltük.
    \item A zöld korong pedig a már megtett távolságot jelöli, amiben tudjuk biztosra, hogy nem ütköztünk.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_0.png}
	\caption{Az ábrán egy leegyszerűsített kétdimenziós kúpkövetés példa eleje látható (első SDF hívás), jelenleg egy darab négy pixeles kúpunk van.}
\end{figure}

A kúpkövetés során, ha akkorát lépnénk, mint amekkora a távolságfüggvény kiértékeléséből származó távolság, akkor lehet, hogy azt vagy egy részét átlépnénk.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_4_1.png}
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_4_2.png}
	\caption{Az ábrákon kékkel vannak jelölve a kritikus területek, amikben ha lennének például kicsi piros körök, akkor azokat átlépnénk.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_2.png}
	\caption{Az ábrán az optimális megoldás látható ehhez a példához (lehető legnagyobbat léptük, úgy, hogy a program helyességét megőriztük).}
\end{figure}

Mivel az optimális megoldást kiszámítása meglehetősen költséges, ez 3D-ben a gúla négy sarok sugarát kéne egy gömbbel metszeni és ráadásul problémás lehet a kúpok felbontásánál is, ha nem jól implementáljuk. Ezért egy közelítést fogunk alkalmazni, aminek a lényege, hogy a kapott távolságból kivonjuk a kúpunk sugarát és csak akkorát lépünk.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_5.png}
	\caption{Az ábrán a baloldali narancssárga pontból hívtuk meg a távolság függvényt, a kék vonal jelöli a kúpunk sugarát, a jobb oldali narancssárga pont lesz az eredménye ennek az iterációnak.}
\end{figure}

Ez a módszer még elfajult helyzetekben is megőrzi a program helyességét.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_15.png}
	\caption{Az ábra egy elfajult helyzetet ábrázol, ahol már szinte végtelen távolságnyira vagyunk a kamerától és a kúp élei majdnem párhuzamosak.}
\end{figure}

A jelenlegi példában a következő két iteráció hasonlóképpen fog kinézni az előbbihez, semmi különös nem fog történni.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_6.png}
	\caption{Az ábrán a kúpkövetés harmadik iterációja látható.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_7.png}
	\caption{Az ábrán a kúpkövetés negyedik iterációja látható.}
\end{figure}

Ha a lépés mértéke túl kicsi, azaz kisebb, mint egy epszilon paraméter, akkor a kúpunkat több kisebb kúpra bontjuk fel.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_8_1.png}
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_8_2.png}
	\caption{Az ábrán a kúpkövetés ötödik iterációja látható, ahol a lépés mértéke már túl kicsi, így nincs nem szükséges tovább folytatni.}
\end{figure}

Jelen esetben ezt az egy nagy kúpunkat fogjuk megfelezni, így lesz belőle két kisebb kúpunk és a már megtett távolságtól tudjuk folytatni azokat, úgy, hogy a program helyességét megőrizzük. Ezek az új kúpok egymástól függetlenül, párhuzamosan is tudnak tovább haladni.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_9.png}
	\caption{Az ábrán a két új kúp látható, amelyek a már biztos távolságtól (zöld) fogják folytatni útjaikat.}
\end{figure}

Most csak a felsőbb kétpixeles kúp mentén fogom részletezni tovább az algoritmust. A zöld korong innentől kezdve csakis a felsőbb kúpra fog vonatkozni a jelölésekben.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_10.png}
	\caption{Az ábrán a felsőbb két pixeles kúpnak az első iterációja látható.}
\end{figure}

Az algoritmus kiszámítása folyamán lehetséges az a helyzet, hogy negatív lesz a lépés mértéke, ebben a helyzetben a visszafelő történő lépésnek nincs értelme, így felbomlik kisebb kúpokra anélkül, hogy lépne.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_11_1.png}
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_11_2.png}
	\caption{Az ábrán a felsőbb két pixeles kúpnak az második iterációja látható, ahol a lépés mértéke megint csak kisebb lenne mint, az epszilon paraméter.}
\end{figure}

Mivel most már a kúpjaink csakis egy-egy „pixeleknek” felelnének meg így nincs értelme tovább alkalmazni a kúpkövetést, ezért majd valamelyik sugárkövető (naiv/relaxált/javított) algoritmussal fogjuk folytatni. Jelen példában ez a naiv módszer lesz az egyszerűség kedvéért.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_12.png}
	\caption{Az ábrán a felsőbb kúpkövetés eredménye látható (zöld) és a két megmaradó sugarunk (szaggatott vonalak).}
\end{figure}

Az algoritmus utolsó lépése, hogy valamelyik hagyományos gömbkövetési módszert (jelenleg naiv) alkalmazza pixelenként a megtett távolságtól.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_13_1.png}
	\includegraphics[width=0.45\textwidth,keepaspectratio,frame]{geogebra/cone_tracing/cone_tracing_13_2.png}
	\caption{Az ábrán a felsőbb kúp felbomlása utáni két sugárnak a naiv gömbkövetései láthatóak.}
\end{figure}

\subsection{A kúpkövetés algoritmus párhuzamosítása}

Ha a kúpkövetés befejezte az iterációt, akkor több kisebb kúpra bomlik, amik az aktuális távolságtól folytatják az iterációt. Én úgy implementáltam ezt, hogy mindig negyedelődik a kúpokat alkotó pixelek száma és négyszereződik a kúpok száma, mindaddig, amíg 2x2-es nem lesz. Majd utána a korábbi módszerek egyikét (alap/relaxált/javított) alkalmazom pixelenként kiindulva a már kúpkövetés által megtett távolságból.

\begin{algorithm}[H]
\caption{Az adaptív kúpkövetés pszeudokódja}
\textbf{\underline{Funct}} Kúpkövetés(paraméterek)
\begin{algorithmic}[1]
\State $K$ kúpok inicializálása, irányaik és méreteik meghatározása, megtett távolság 0.0 ra állítása
\State $\text{kúpméret} \gets$ kezdeti kúpméret paraméter
\State
\While{(\textbf{kúpméret} $\ge 2$)}
    \State \textbf{parallel for each} kúp $k \in K$
		\State \quad $k$ kúp irányát beszorozzuk az inverz nézeti mátrixxal
        \State \quad iterálás a $k$ kúp mentén, amíg a feltételek (max távolság, max iterációszám, \dots) igazak
    \State \textbf{end parallel for}
	\State
    \State memória szinkronizáció
	\State
    \State kúpok felbontása $\,\Rightarrow\,$ új kúpok listája $K_{\text{new}}$
	\State
    \State \textbf{parallel for each} kúp $k_{\text{new}} \in K_{\text{new}}$
		\State \quad $k_{\text{new}}$ beállítja kezdő távolságát a megfelelő $k$ által megtett távolságra
    \State \textbf{end parallel for}
	\State
    \State $K \gets K_{\text{new}}$
    \State \text{kúpméret} $\gets$ \text{kúpméret} / 2
\EndWhile

\State \Comment{A kúpok már csak 1-1 pixelnek felelnek meg}

\State \textbf{parallel for each} kúp $k \in K$
    \State \quad a naiv/relaxált/javított módszer alkalmazása
\State \textbf{end parallel for}

\end{algorithmic}
\end{algorithm}

Példaként legyen egy kitalált képernyő, ami 1920x1080 pixeles és a kezdeti kúpméret legyen 8x8, a kúpkövetés ebben az esetben úgy nézne ki, hogy:

\begin{enumerate}
	\item 240x135 szálon a 8x8 pixeles kúpokat követjük
	\item szinkronizáció
	\item 480x270 szálon 4x4 pixeles kúpok a megfelelő 8x8-as kúp eredményéből indítva
	\item szinkronizáció
	\item 960x540 szálon 2x2 pixeles kúpok a 4x4-es eredményeit felhasználva
	\item szinkronizáció
	\item alap/relaxált/javított sugárkövetés pixelenként (1920x1080 szálon) a megfelelő 2x2-es kúpok eredményeit felhasználva
\end{enumerate}

A gyorsítás itt abból fog adódni, hogy az SDF kiértékelések száma összességében kevesebb lesz, ami általában a domináns faktor a számítási időben. Ez a módszer azt használja ki, hogy szomszédos sugarak a kiindulási ponttól vett adott távolságra lévő SDF kiértékeléseikből származó távolságaik nagyban hasonlítanak, így úgymond össze lehet vonni azokat.

\subsection{A kúpkövetés nagy limitációja}

A probléma az az, hogy az első metszés után a kúpkövetés folytatása nehézkes, mivel ha a sugár tükröződik/megtörik, akkor jó eséllyel más irányba fog indulni, mint valamelyik szomszédja, így csak nagyon nagy kúpot tudnánk definiálni.

\subsection{Relaxált/javított kúpkövetés}

Kis módosítással a relaxált/javított módszert is tudjuk alkalmazni a kúpkövetésre, azaz a lépés mértékét valamilyen értékkel, legyen az konstans/heurisztikus beszorozzuk, ha pedig a lépés mértéke túl nagy, akkor hasonlóan az eredeti módszerekhez visszalépünk. Ez meglehetősen jól fog működni, hiszen a kúpok általában nagyon keskenyek, mivel a GPU jó kihasználtsága érdekében általában nem praktikus 8x8 vagy 16x16 pixeles gúláknál nagyobbakból kiindulni, amik meglehetősen keskeny kúpokat adnak.




